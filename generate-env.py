#!/usr/bin/env python3
"""
Environment Configuration Generator for Iris AI
This script generates .env files for both local and production environments
based on the master configuration file.
"""

import os
import re
from pathlib import Path

def read_master_config():
    """Read the master environment configuration file."""
    master_file = Path("env.config.master")
    if not master_file.exists():
        print("‚ùå env.config.master file not found!")
        return None
    
    config = {}
    with open(master_file, 'r') as f:
        for line in f:
            line = line.strip()
            if line and not line.startswith('#') and '=' in line:
                key, value = line.split('=', 1)
                config[key.strip()] = value.strip()
    
    return config

def generate_backend_env(config, env_mode):
    """Generate backend .env file."""
    backend_env = []
    
    # Add all backend variables
    backend_vars = [
        'SUPABASE_URL', 'SUPABASE_ANON_KEY', 'SUPABASE_SERVICE_ROLE_KEY',
        'REDIS_HOST', 'REDIS_PORT', 'GEMINI_API_KEY', 'MODEL_TO_USE',
        'MORPH_API_KEY', 'TAVILY_API_KEY', 'FIRECRAWL_API_KEY', 'FIRECRAWL_URL',
        'RAPID_API_KEY', 'QSTASH_URL', 'QSTASH_TOKEN', 'QSTASH_CURRENT_SIGNING_KEY',
        'QSTASH_NEXT_SIGNING_KEY', 'SLACK_CLIENT_ID', 'SLACK_CLIENT_SECRET',
        'SLACK_REDIRECT_URI', 'WEBHOOK_BASE_URL', 'MCP_CREDENTIAL_ENCRYPTION_KEY',
        'PIPEDREAM_PROJECT_ID', 'PIPEDREAM_CLIENT_ID', 'PIPEDREAM_CLIENT_SECRET',
        'PIPEDREAM_X_PD_ENVIRONMENT', 'DAYTONA_API_KEY', 'DAYTONA_SERVER_URL',
        'DAYTONA_TARGET', 'KORTIX_ADMIN_API_KEY', 'ENABLE_ADAPTIVE_MODE',
        'LOG_LEVEL', 'IRIS_DEBUG', 'IRIS_REQUIRE_DAYTONA'
    ]
    
    for var in backend_vars:
        if var in config:
            backend_env.append(f"{var}={config[var]}")
    
    # Add environment-specific variables
    backend_env.append(f"ENV_MODE={env_mode}")
    
    # Add CORS configuration
    if env_mode == 'production':
        backend_env.append("CORS_ORIGINS=https://irisvision.ai,https://www.irisvision.ai")
    else:
        backend_env.append("CORS_ORIGINS=http://localhost:3000")
    
    return backend_env

def generate_frontend_env(config, env_mode):
    """Generate frontend .env.local file."""
    frontend_env = []
    
    # Add Supabase configuration
    frontend_env.append(f"NEXT_PUBLIC_SUPABASE_URL={config['SUPABASE_URL']}")
    frontend_env.append(f"NEXT_PUBLIC_SUPABASE_ANON_KEY={config['SUPABASE_ANON_KEY']}")
    
    # Add environment-specific URLs
    if env_mode == 'production':
        frontend_env.append("NEXT_PUBLIC_BACKEND_URL=https://irisvision.ai/api")
        frontend_env.append("NEXT_PUBLIC_URL=https://irisvision.ai")
        frontend_env.append("NEXT_PUBLIC_ENV_MODE=PRODUCTION")
    else:
        frontend_env.append("NEXT_PUBLIC_BACKEND_URL=http://localhost:8000")
        frontend_env.append("NEXT_PUBLIC_URL=http://localhost:3000")
        frontend_env.append("NEXT_PUBLIC_ENV_MODE=LOCAL")
    
    # Add other frontend variables
    frontend_vars = [
        'KORTIX_ADMIN_API_KEY', 'NEXT_PUBLIC_GOOGLE_CLIENT_ID',
        'NEXT_PUBLIC_GOOGLE_CLIENT_SECRET', 'GEMINI_API_KEY', 'MODEL_TO_USE'
    ]
    
    for var in frontend_vars:
        if var in config:
            frontend_env.append(f"{var}={config[var]}")
    
    # Add Redis host for frontend
    frontend_env.append(f"REDIS_HOST={config['REDIS_HOST']}")
    
    return frontend_env

def generate_root_env(config, env_mode):
    """Generate root .env file."""
    root_env = []
    
    # Add all variables from master config
    for key, value in config.items():
        if key != 'ENV_MODE':  # Skip ENV_MODE as it's set separately
            root_env.append(f"{key}={value}")
    
    # Add environment-specific variables
    root_env.append(f"ENV_MODE={env_mode}")
    
    # Add CORS configuration
    if env_mode == 'production':
        root_env.append("CORS_ORIGINS=https://irisvision.ai,https://www.irisvision.ai")
    else:
        root_env.append("CORS_ORIGINS=http://localhost:3000")
    
    return root_env

def write_env_file(content, filepath):
    """Write environment variables to a file."""
    filepath = Path(filepath)
    filepath.parent.mkdir(parents=True, exist_ok=True)
    
    with open(filepath, 'w') as f:
        f.write(f"# Generated by generate-env.py\n")
        f.write(f"# Environment: {os.getenv('ENV_MODE', 'unknown')}\n\n")
        for line in content:
            f.write(f"{line}\n")
    
    print(f"‚úÖ Generated {filepath}")

def main():
    """Main function to generate environment files."""
    print("üöÄ Iris AI Environment Configuration Generator")
    print("=" * 50)
    
    # Read master configuration
    config = read_master_config()
    if not config:
        return
    
    # Get environment mode
    env_mode = config.get('ENV_MODE', 'local')
    print(f"üìã Environment Mode: {env_mode.upper()}")
    
    # Generate backend .env
    backend_env = generate_backend_env(config, env_mode)
    write_env_file(backend_env, "backend/.env")
    
    # Generate frontend .env.local
    frontend_env = generate_frontend_env(config, env_mode)
    write_env_file(frontend_env, "frontend/.env.local")
    
    # Generate root .env
    root_env = generate_root_env(config, env_mode)
    write_env_file(root_env, ".env")
    
    print("\nüéâ Environment files generated successfully!")
    print(f"üåç Current environment: {env_mode.upper()}")
    print("\nüìù To switch environments:")
    print("1. Edit env.config.master")
    print("2. Change ENV_MODE to 'local' or 'production'")
    print("3. Run: python generate-env.py")
    print("\nüîß Files generated:")
    print("   - .env (root)")
    print("   - backend/.env")
    print("   - frontend/.env.local")

if __name__ == "__main__":
    main()
